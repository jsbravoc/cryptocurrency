const validator=require("validator"),{hash512}=require("../controllers/common"),{TYPE}=require("../utils/constants"),{ERRORS}=require("../utils/errors"),{MAXIMUM_FLOAT_PRECISION}=require("../utils/constants"),{validateObjExistence}=require("./common"),createSignature=(r,t=new Date)=>hash512(`${r}${t.getTime()}`),inputValidation=r=>{let t=r;if(void 0===r.recipient||validator.isEmpty(`${r.recipient}`))throw Error("Transaction format error: missing a recipient");if(t.recipient=r.recipient.trim(),void 0===r.amount||validator.isEmpty(`${r.amount}`)||!validator.isFloat(`${r.amount}`,{gt:0}))throw Error("Transaction format error: missing a valid amount");if(t.amount=Number(validator.toFloat(`${r.amount}`).toFixed(MAXIMUM_FLOAT_PRECISION)),void 0===r.signature||validator.isEmpty(`${r.signature}`))throw Error("Transaction format error: missing a signature");if(t.signature=r.signature.trim(),void 0===r.address||validator.isEmpty(`${r.address}`))throw Error("Transaction format error: missing an address");if(t.address=r.address.trim(),void 0===r.sender||validator.isEmpty(`${r.sender}`)||(t.sender=r.sender.trim()),void 0!==r.valid_thru&&!validator.isEmpty(`${r.valid_thru}`)&&!validator.isISO8601(`${r.valid_thru}`))throw Error("Transaction format error: valid_thru date format is not ISO 8601");if(void 0!==r.valid_thru&&(t.valid_thru=validator.toDate(`${r.valid_thru}`)),void 0!==r.creationDate&&!validator.isEmpty(`${r.creationDate}`)&&!validator.isISO8601(`${r.creationDate}`))throw Error("Transaction format error: creationDate date format is not ISO 8601");if(void 0!==r.creationDate&&(t.creationDate=validator.toDate(`${r.creationDate}`)),t.valid_thru&&t.creationDate>t.valid_thru)throw Error("Transaction format error: valid_thru date is before creationDate");if(void 0!==r.pending&&!validator.isEmpty(`${r.pending}`)&&!validator.isBoolean(`${r.pending}`))throw Error("Transaction format error: pending is not boolean");return t.valid=!(void 0!==r.pending&&!validator.isEmpty(`${r.pending}`))||!validator.toBoolean(`${r.pending}`),t},postTxValidationChain=(a,e)=>new Promise((r,t)=>{try{r(inputValidation(e))}catch(r){t(r)}}).then(i=>{let r=[validateObjExistence(a,TYPE.TRANSACTION,i.address,!1),validateObjExistence(a,TYPE.USER,i.recipient,!0)];return i.sender&&r.push(validateObjExistence(a,TYPE.USER,i.sender,!0)),Promise.all(r).then(([,r,t])=>{if(!1===r.active)return Promise.reject("ERRORS.USER.LOGIC.USER_IS_NOT_ACTIVE");if(t){if(!1===t.active)return Promise.reject("ERRORS.USER.LOGIC.USER_IS_NOT_ACTIVE");if(t.permissions&&t.permissions.transfer_to&&!1===t.permissions.transfer_to[i.recipient])return Promise.reject("ERRORS.USER.LOGIC.USER_DOES_NOT_HAVE_TRANSFER_PERMISSIONS");if(t.balance<i.amount)return Promise.reject("ERRORS.USER.INPUT.INSUFFICIENT_FUNDS");if(!Array.isArray(t.latest_transactions)||0===t.latest_transactions.length)return Promise.reject("ERRORS.USER.INPUT.NO_TRANSACTIONS");if(!(!0!==i.valid||i.supporting_transactions&&Array.isArray(i.supporting_transactions)&&0!==i.supporting_transactions.length))return Promise.reject("ERRORS.TRANSACTION.INPUT.NO_SUPPORTING_TRANSACTIONS");if(Array.isArray(i.supporting_transactions)&&0<i.supporting_transactions.length){const e=[];return i.supporting_transactions.forEach(r=>{e.push(validateObjExistence(a,TYPE.TRANSACTION,r,!0).then(r=>r.recipient!==t.address?Promise.reject("ERRORS.TRANSACTION.LOGIC.TRANSACTION_OWNERSHIP_MISMATCH"):r))}),Promise.all(e).then(r=>{let t=i.amount;if(r.forEach(r=>{t-=r.amount}),0<t)return Promise.reject("ERRORS.TRANSACTION.LOGIC.INSUFFICIENT_SUPPORTING_TRANSACTIONS")}).catch(r=>Promise.reject(r))}}else if(r&&r.permissions&&!0!==r.permissions.coinbase)return Promise.reject("ERRORS.USER.LOGIC.USER_DOES_NOT_HAVE_PERMISSIONS")}).catch(r=>(console.log("Catched error: ",r),Promise.reject(r)))}),putTxValidationChain=(n,e)=>new Promise((r,t)=>{try{r(e)}catch(r){t(r)}}).then(a=>{let r=[validateObjExistence(n,TYPE.TRANSACTION,a.address,!0)];return!1===a.pending&&(!a.valid_thru||new Date(a.valid_thru)>new Date)&&(console.log("Obj",a),r.push(validateObjExistence(n,TYPE.USER,a.recipient,!0)),a.sender&&r.push(validateObjExistence(n,TYPE.USER,a.sender,!0))),Promise.all(r).then(([r,t,e])=>{if(console.log("sanitizedObj",a),!0!==r.pending){if(r.valid_thru&&new Date(r.valid_thru)>new Date)return Promise.reject("ERRORS.TRANSACTION.LOGIC.TRANSACTION_IS_NOT_EXPIRED");if(!r.valid_thru)return Promise.reject("ERRORS.TRANSACTION.INPUT.TRANSACTION_IS_NOT_PENDING")}if(!0===a.valid){if(!1===t.active)return Promise.reject("ERRORS.USER.LOGIC.USER_IS_NOT_ACTIVE");if(e){if(!1===e.active)return Promise.reject("ERRORS.USER.LOGIC.USER_IS_NOT_ACTIVE");if(e.permissions&&e.permissions.transfer_to&&!1===e.permissions.transfer_to[a.recipient])return Promise.reject("ERRORS.USER.LOGIC.USER_DOES_NOT_HAVE_TRANSFER_PERMISSIONS");if(e.balance<a.amount)return Promise.reject("ERRORS.USER.INPUT.INSUFFICIENT_FUNDS");if(!Array.isArray(e.latest_transactions)||0===e.latest_transactions.length)return Promise.reject("ERRORS.USER.INPUT.NO_TRANSACTIONS");if(!a.supporting_transactions||!Array.isArray(a.supporting_transactions)||0===a.supporting_transactions.length)return Promise.reject("ERRORS.TRANSACTION.INPUT.NO_SUPPORTING_TRANSACTIONS");if(Array.isArray(a.supporting_transactions)&&0<a.supporting_transactions.length){const i=[];return a.supporting_transactions.forEach(r=>{i.push(validateObjExistence(n,TYPE.TRANSACTION,r,!0).then(r=>r.recipient!==e.address?Promise.reject("ERRORS.TRANSACTION.LOGIC.TRANSACTION_OWNERSHIP_MISMATCH"):r))}),Promise.all(i).then(r=>{let t=a.amount;if(r.forEach(r=>{t-=r.amount}),0<t)return Promise.reject("ERRORS.TRANSACTION.LOGIC.INSUFFICIENT_SUPPORTING_TRANSACTIONS")}).catch(r=>Promise.reject(r))}}else if(t&&t.permissions&&!0!==t.permissions.coinbase)return Promise.reject("ERRORS.USER.LOGIC.USER_DOES_NOT_HAVE_PERMISSIONS")}else if((!a.valid_thru||new Date(r.valid_thru)>new Date)&&Array.isArray(a.supporting_transactions)&&0<a.supporting_transactions.length)return Promise.reject("ERRORS.TRANSACTION.INPUT.INVALID_SUPPORTED_TRANSACTION")}).catch(r=>(console.log("Catched error: ",r),Promise.reject(r)))});module.exports.inputValidation=inputValidation,module.exports.postTxValidationChain=postTxValidationChain,module.exports.putTxValidationChain=putTxValidationChain;