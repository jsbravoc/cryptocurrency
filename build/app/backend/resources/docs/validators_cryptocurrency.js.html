

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> validators/cryptocurrency.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-MongoUtils.html">MongoUtils</a></li></ul><h3>Classes</h3><ul><li><a href="Asset.html">Asset</a></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="Transaction.html">Transaction</a></li><li><a href="User.html">User</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_putAsset">_putAsset</a></li><li><a href="global.html#_updateTransaction">_updateTransaction</a></li><li><a href="global.html#_updateUser">_updateUser</a></li><li><a href="global.html#buildAssetTransaction">buildAssetTransaction</a></li><li><a href="global.html#buildBatch">buildBatch</a></li><li><a href="global.html#createTransaction">createTransaction</a></li><li><a href="global.html#expandSupportingTransactions">expandSupportingTransactions</a></li><li><a href="global.html#findAllAssets">findAllAssets</a></li><li><a href="global.html#findByAddress">findByAddress</a></li><li><a href="global.html#findTransaction">findTransaction</a></li><li><a href="global.html#findUser">findUser</a></li><li><a href="global.html#getAddress">getAddress</a></li><li><a href="global.html#getSupportingTransactions">getSupportingTransactions</a></li><li><a href="global.html#getTransactionAddress">getTransactionAddress</a></li><li><a href="global.html#getTransactionByAddress">getTransactionByAddress</a></li><li><a href="global.html#getTransactions">getTransactions</a></li><li><a href="global.html#getUserAddress">getUserAddress</a></li><li><a href="global.html#getUserByAddress">getUserByAddress</a></li><li><a href="global.html#getUsers">getUsers</a></li><li><a href="global.html#hash512">hash512</a></li><li><a href="global.html#http">http</a></li><li><a href="global.html#inputValidation">inputValidation</a></li><li><a href="global.html#normalizePort">normalizePort</a></li><li><a href="global.html#onError">onError</a></li><li><a href="global.html#port">port</a></li><li><a href="global.html#putAsset">putAsset</a></li><li><a href="global.html#putBatch">putBatch</a></li><li><a href="global.html#server">server</a></li><li><a href="global.html#updateTransaction">updateTransaction</a></li><li><a href="global.html#validate">validate</a></li><li><a href="global.html#validateAssetExistence">validateAssetExistence</a></li><li><a href="global.html#validateExistingTransaction">validateExistingTransaction</a></li><li><a href="global.html#validatePendingTransaction">validatePendingTransaction</a></li><li><a href="global.html#validateTransactionAddress">validateTransactionAddress</a></li><li><a href="global.html#validateTransactionUpdateRequest">validateTransactionUpdateRequest</a></li><li><a href="global.html#validateUserCreation">validateUserCreation</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>validators/cryptocurrency.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { body } = require("express-validator");
const { TYPE } = require("../utils/constants");
const { ERRORS } = require("../utils/errors");
const {
  validate,
  createError,
  validateAssetExistence,
  createErrorObj,
} = require("./common");
const { findByAddress } = require("../controllers/common");
const Transaction = require("../models/Transaction");
const { MAXIMUM_FLOAT_PRECISION } = require("../utils/constants");
const { getPublicKey } = require("../utils/signature");

/**
 * Verifies if a transaction's request body is valid.
 * Conditions:
 *    recipient must be a non-empty String
 *    amount must be a float number greater than zero
 *    signature must be a non-empty String
 *    valid must be false if transaction is pending
 *    valid must be a boolean
 * *  pending must be a boolean
 *
 * @post Sanitizes and Allows the request to continue if the request body is valid, denies the request otherwise.
 */
const inputValidation = validate([
  body("recipient")
    .notEmpty()
    .withMessage((value, { req }) =>
      createErrorObj(req, {
        error: ERRORS.TRANSACTION.INPUT.MISSING_REQUIRED_INPUT,
        params: {
          param: "recipient",
          value,
        },
      })
    )
    .trim()
    .bail(),
  body("amount")
    .notEmpty()
    .isFloat({ gt: 0 })
    .toFloat()
    .withMessage((value, { req }) =>
      createErrorObj(req, {
        error: ERRORS.TRANSACTION.INPUT.INCORRECT_INPUT,
        params: {
          param: "amount",
          value,
        },
      })
    )
    .bail(),
  body("amount").customSanitizer((value) => {
    if (value) {
      return Number(value.toFixed(MAXIMUM_FLOAT_PRECISION));
    }
  }),
  body("signature")
    .notEmpty()
    .withMessage((value, { req }) =>
      createErrorObj(req, {
        error: ERRORS.TRANSACTION.INPUT.MISSING_REQUIRED_INPUT,
        params: {
          param: "signature",
          value,
        },
      })
    )
    .trim()
    .bail(),
  body("sender").optional({ checkFalsy: true, checkNull: true }).trim(),
  body("valid_thru")
    .optional({ checkFalsy: true, checkNull: true })
    .isISO8601()
    .toDate()
    .withMessage((value, { req }) =>
      createErrorObj(req, {
        error: ERRORS.TRANSACTION.INPUT.INCORRECT_INPUT,
        params: {
          param: "valid_thru",
          value,
          message: "The valid_thru date must be in ISO 8601 format",
        },
      })
    )
    .bail(),
  body("supporting_transactions").customSanitizer(() => undefined),
  body("creationDate").customSanitizer(() => undefined),
  body("valid_thru").custom((value, { req }) => {
    if (value &amp;&amp; new Date(value) &lt; new Date())
      return Promise.reject(
        createErrorObj(req, {
          error: ERRORS.TRANSACTION.INPUT.INCORRECT_INPUT,
          params: {
            param: "valid_thru",
            value,
            message:
              "The valid_thru date must be after the transaction creation date",
          },
        })
      );
    return true;
  }),
  body("valid").customSanitizer((value, { req }) => {
    if (
      req.body.pending !== null &amp;&amp;
      req.body.pending !== undefined &amp;&amp;
      (req.body.pending === true || req.body.pending === "true")
    ) {
      return false;
    }
    return value;
  }),
  body("pending").optional({ checkNull: true }).toBoolean(),
  body("valid").optional({ checkNull: true }).toBoolean(),
]);

/**
 * Verifies if a transaction already exists.
 *
 * @post Allows the request to continue if the transaction exists, denies the request otherwise.
 */
const validateExistingTransaction = (
  req,
  res,
  next,
  address,
  shouldExist,
  { location = "body" } = null
) => {
  return validateAssetExistence(
    TYPE.TRANSACTION,
    address,
    shouldExist,
    req,
    res,
    {
      location,
    }
  )
    .then(() => {
      next();
    })
    .catch((callback) => {
      return callback();
    });
};

const verifyPostTransaction = (req, res, next) => {
  const promises = [
    findByAddress(TYPE.USER, req.body.recipient, false, false, res),
  ];
  if (req.body.sender) {
    promises.push(findByAddress(TYPE.USER, req.body.sender, false, false, res));
  }
  return Promise.all(promises).then(([recipientUser, senderUser]) => {
    if (!recipientUser) {
      return createError(req, res, {
        error: ERRORS.USER.INPUT.USER_DOES_NOT_EXIST,
        params: {
          address: req.body.recipient,
          param: "recipient",
          value: req.body.recipient,
        },
      });
    } else if (recipientUser &amp;&amp; recipientUser.active === false) {
      return createError(req, res, {
        error: ERRORS.USER.LOGIC.USER_IS_NOT_ACTIVE,
        params: {
          address: req.body.recipient.address,
          param: "recipient",
          value: req.body.recipient.address,
        },
      });
    } else if (req.body.sender &amp;&amp; !senderUser) {
      return createError(req, res, {
        error: ERRORS.USER.INPUT.USER_DOES_NOT_EXIST,
        params: {
          address: req.body.sender,
          param: "sender",
          value: req.body.sender,
        },
      });
    } else if (senderUser &amp;&amp; senderUser.active === false) {
      return createError(req, res, {
        error: ERRORS.USER.LOGIC.USER_IS_NOT_ACTIVE,
        params: {
          address: req.body.sender,
          param: "sender",
          value: req.body.sender,
        },
      });
    } else if (senderUser) {
      if (
        senderUser.permissions &amp;&amp;
        senderUser.permissions.transfer_to &amp;&amp;
        senderUser.permissions.transfer_to[req.body.recipient] === false
      ) {
        return createError(req, res, {
          error: ERRORS.USER.LOGIC.USER_DOES_NOT_HAVE_TRANSFER_PERMISSIONS,
          params: {
            address: req.body.sender,
            recipient: req.body.recipient,
            param: "sender",
            value: req.body.sender,
          },
        });
      } else {
        if (senderUser.balance &lt; req.body.amount) {
          return createError(req, res, {
            error: ERRORS.USER.INPUT.INSUFFICIENT_FUNDS,
            params: {
              address: req.body.sender,
              param: "amount",
              value: req.body.sender,
            },
          });
        } else if (
          !Array.isArray(senderUser.latest_transactions) ||
          senderUser.latest_transactions.length === 0
        ) {
          return createError(req, res, {
            error: ERRORS.USER.INPUT.NO_TRANSACTIONS,
            params: {
              address: req.body.sender,
              param: "sender",
              value: req.body.sender,
            },
          });
        } else {
          let amountToFulfill = req.body.amount;
          let actualBalance = 0;
          let returnedError = false;
          const lastestTxPromises = [];
          (senderUser.latest_transactions || []).forEach((txid) => {
            lastestTxPromises.push(
              findByAddress(TYPE.TRANSACTION, txid, false, false, res).then(
                (supportingTransaction) => {
                  if (!supportingTransaction) {
                    returnedError = true;
                    return createError(req, res, {
                      error: ERRORS.USER.LOGIC.NONEXISTENT_LASTEST_TRANSACTION,
                      params: {
                        address: req.body.sender,
                        param: "sender",
                        value: req.body.sender,
                        transactionSignature: txid,
                      },
                    });
                  } else if (
                    supportingTransaction.recipient !== req.body.sender
                  ) {
                    returnedError = true;
                    return createError(req, res, {
                      error:
                        ERRORS.USER.LOGIC
                          .INCORRECT_RECIPIENT_LASTEST_TRANSACTION,
                      params: {
                        address: req.body.sender,
                        param: "sender",
                        value: req.body.sender,
                        transactionSignature: txid,
                      },
                    });
                  } else {
                    amountToFulfill -= supportingTransaction.amount;
                    actualBalance += supportingTransaction.amount;
                  }
                }
              )
            );
          });
          return Promise.all(lastestTxPromises).then(() => {
            if (returnedError) {
              return;
            }
            const copyOfAmountToFulfill = amountToFulfill;
            let amountPending = 0;
            const pendingTxPromises = [];

            (senderUser.pending_transactions || []).forEach((txid) => {
              pendingTxPromises.push(
                findByAddress(TYPE.TRANSACTION, txid, false, false, res).then(
                  (pendingTransaction) => {
                    if (!pendingTransaction) {
                      returnedError = true;
                      return createError(req, res, {
                        error:
                          ERRORS.USER.LOGIC.NONEXISTENT_PENDING_TRANSACTION,
                        params: {
                          address: req.body.sender,
                          param: "sender",
                          value: req.body.sender,
                          transactionSignature: txid,
                        },
                      });
                    }
                    if (pendingTransaction.creator === req.body.sender) {
                      amountPending += pendingTransaction.amount;
                      amountToFulfill += pendingTransaction.amount;
                      actualBalance -= pendingTransaction.amount;
                    }
                  }
                )
              );
            });

            return Promise.all(pendingTxPromises).then(() => {
              if (returnedError) {
                return;
              } else {
                if (amountToFulfill > 0) {
                  returnedError = true;
                  if (amountToFulfill !== copyOfAmountToFulfill)
                    return createError(req, res, {
                      error:
                        ERRORS.USER.INPUT
                          .INSUFFICIENT_FUNDS_PENDING_TRANSACTIONS,
                      params: {
                        address: req.body.sender,
                        param: "amount",
                        value: req.body.sender,
                        amountPending,
                        actualBalance,
                      },
                    });
                  else
                    return createError(req, res, {
                      error:
                        ERRORS.USER.INPUT.INSUFFICIENT_FUNDS_UNEXPECTED_BALANCE,
                      params: {
                        address: req.body.sender,
                        param: "amount",
                        value: req.body.sender,
                        actualBalance,
                      },
                    });
                }
              }
              return next();
            });
          });
        }
      }
    } else if (
      recipientUser &amp;&amp;
      recipientUser.permissions &amp;&amp;
      recipientUser.permissions.coinbase !== true
    ) {
      return createError(req, res, {
        error: ERRORS.USER.LOGIC.USER_DOES_NOT_HAVE_PERMISSIONS,
        params: {
          address: req.body.recipient,
          param: "recipient",
          value: req.body.recipient,
          requiredPermission: "coinbase",
        },
      });
    } else {
      return next();
    }
  });
};

/**
 * Verifies if a transaction is pending.
 *
 * @post Allows the request to continue if the transaction is pending, denies the request otherwise.
 */
const validatePendingTransaction = async (req, res, next) => {
  const { address } = req.params;
  return findByAddress(TYPE.TRANSACTION, address, false, false, res).then(
    (transaction) => {
      if (transaction.pending) {
        return next();
      }
      return createError(req, res, {
        error: ERRORS.TRANSACTION.INPUT.TRANSACTION_IS_NOT_PENDING,
        params: {
          signature: req.params.address,
          param: "address",
          value: req.params.address,
        },
      });
    }
  );
};

/**
 * Validation chain of a transaction get/put request
 */
const validateTransactionAddress = [
  (req, res, next) =>
    validateExistingTransaction(req, res, next, req.params.address, true, {
      location: "params",
    }),
];

const validateTransactionSignature = (req, res, next) => {
  if (process.env.DISABLE_INTEGRITY_VALIDATION === "true") return next();
  const { creator, sender, recipient, signature } = req.body;
  const transaction = new Transaction(req.body).toSignatureString();
  const expectedPublicKey = getPublicKey(transaction, signature);
  if (expectedPublicKey) {
    return findByAddress(
      TYPE.USER,
      creator || sender || recipient,
      false,
      false,
      res
    ).then((user) => {
      if (user.public_key !== expectedPublicKey) {
        return createError(req, res, {
          error: ERRORS.TRANSACTION.LOGIC.NON_MATCHING_KEYS,
          params: {
            param: "signature",
            value: req.body.signature,
          },
        });
      }
      return next();
    });
  } else
    return createError(req, res, {
      error: ERRORS.TRANSACTION.LOGIC.DECRYPTING_ERROR,
      params: {
        param: "signature",
        value: req.body.signature,
      },
    });
};

const validateTransactionApproval = (req, res, next) => {
  if (process.env.DISABLE_INTEGRITY_VALIDATION === "true") return next();
  const { address } = req.params;
  const { approve } = req.query;
  const signature = req.query.signature || req.body.signature;
  if (approve === undefined) return next();
  else if (signature === undefined)
    return createError(req, res, {
      error: ERRORS.TRANSACTION.INPUT.MISSING_REQUIRED_INPUT,
      location: "query",
      params: {
        param: "signature",
      },
    });
  else if (approve !== "true" &amp;&amp; approve !== "false") {
    return createError(req, res, {
      error: ERRORS.TRANSACTION.INPUT.INCORRECT_INPUT,
      location: "query",
      params: {
        param: "signature",
      },
    });
  }

  return findByAddress(TYPE.TRANSACTION, address, false, false, res).then(
    (transaction) => {
      const signatureObj = { approve: approve === "true" };
      if (req.body.description) {
        signatureObj.description = req.body.description;
      }
      const expectedPublicKey = getPublicKey(
        JSON.stringify(signatureObj),
        signature
      );
      if (expectedPublicKey) {
        const promises = [];

        promises.push(
          findByAddress(TYPE.USER, transaction.sender, false, false, res)
        );
        //transaction can be rejected by recipient
        if (approve === "false")
          promises.push(
            findByAddress(TYPE.USER, transaction.recipient, false, false, res)
          );
        return Promise.all(promises).then(([sender, recipient]) => {
          if (
            recipient &amp;&amp;
            recipient.public_key !== expectedPublicKey &amp;&amp;
            sender.public_key !== expectedPublicKey
          ) {
            return createError(req, res, {
              error: ERRORS.TRANSACTION.LOGIC.NON_MATCHING_KEYS,
              location: "query",
              params: {
                param: "signature",
                value: req.params.signature,
              },
            });
          }
          if (!recipient &amp;&amp; sender.public_key !== expectedPublicKey) {
            return createError(req, res, {
              error: ERRORS.TRANSACTION.LOGIC.NON_MATCHING_KEYS,
              location: "query",
              params: {
                param: "signature",
                value: req.params.signature,
              },
            });
          }
          return next();
        });
      } else
        return createError(req, res, {
          error: ERRORS.TRANSACTION.LOGIC.DECRYPTING_ERROR,
          location: "query",
          params: {
            param: "signature",
            value: req.params.signature,
          },
        });
    }
  );
};

const validateTransactionUpdate = (req, res, next) => {
  if (process.env.DISABLE_INTEGRITY_VALIDATION === "true") return next();
  const { address } = req.params;
  const { approve } = req.query;
  const { description, signature } = req.body;
  //Validated by validateTransactionApproval
  if (approve !== undefined) return next();
  else if (signature === undefined)
    return createError(req, res, {
      error: ERRORS.TRANSACTION.INPUT.MISSING_REQUIRED_INPUT,
      location: "body",
      params: {
        param: "signature",
      },
    });
  else if (description === undefined)
    return createError(req, res, {
      error: ERRORS.TRANSACTION.INPUT.MISSING_REQUIRED_INPUT,
      location: "body",
      params: {
        param: "description",
      },
    });
  return findByAddress(TYPE.TRANSACTION, address, false, false, res).then(
    (transaction) => {
      const expectedPublicKey = getPublicKey(
        JSON.stringify({ description }),
        signature
      );
      if (expectedPublicKey) {
        const promises = [
          findByAddress(TYPE.USER, transaction.creator, false, false, res),
          findByAddress(TYPE.USER, transaction.sender, false, false, res),
        ];
        return Promise.all(promises).then(([creator, sender]) => {
          if (
            creator.public_key !== expectedPublicKey &amp;&amp;
            sender.public_key !== expectedPublicKey
          ) {
            return createError(req, res, {
              error: ERRORS.TRANSACTION.LOGIC.NON_MATCHING_KEYS,
              params: {
                param: "signature",
                value: req.body.signature,
              },
            });
          }
          return next();
        });
      } else
        return createError(req, res, {
          error: ERRORS.TRANSACTION.LOGIC.DECRYPTING_ERROR,
          params: {
            param: "signature",
            value: req.body.signature,
          },
        });
    }
  );
};

/**
 * Validation chain of a transaction update request
 */
const validateTransactionUpdateRequest = [
  validatePendingTransaction,
  validateTransactionApproval,
  validateTransactionUpdate,
];
module.exports.validateTransactionAddress = validateTransactionAddress;
module.exports.validateTransactionUpdateRequest = validateTransactionUpdateRequest;
module.exports.verifyPostTransaction = [
  /* Transactions signatures don't collide anymore.
  (req, res, next) =>
    validateExistingTransaction(req, res, next, req.body.signature, false, {
      location: "body",
    }), */
  verifyPostTransaction,
  validateTransactionSignature,
];
module.exports.inputValidation = inputValidation;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

</body>
</html>
