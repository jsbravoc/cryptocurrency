<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: validators/cryptocurrency.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: validators/cryptocurrency.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { body } = require("express-validator");
const { TYPE } = require("../utils/constants");
const { ERRORS } = require("../utils/errors");
const {
  validate,
  createError,
  validateAssetExistence,
  createErrorObj,
} = require("./common");
const { findByAddress } = require("../controllers/common");
const Transaction = require("../models/Transaction");
const { MAXIMUM_FLOAT_PRECISION } = require("../utils/constants");
const { getPublicKey } = require("../utils/signature");

/**
 * Verifies if a transaction's request body is valid.
 * Conditions:
 *    recipient must be a non-empty String
 *    amount must be a float number greater than zero
 *    signature must be a non-empty String
 *    valid must be false if transaction is pending
 *    valid must be a boolean
 * *  pending must be a boolean
 *
 * @post Sanitizes and Allows the request to continue if the request body is valid, denies the request otherwise.
 */
const inputValidation = validate([
  body("recipient")
    .notEmpty()
    .withMessage((value, { req }) =>
      createErrorObj(req, {
        error: ERRORS.TRANSACTION.INPUT.MISSING_REQUIRED_INPUT,
        params: {
          param: "recipient",
          value,
          message: "The recipient of the transaction is required",
        },
      })
    )
    .trim()
    .bail(),
  body("amount")
    .notEmpty()
    .isFloat({ gt: 0 })
    .toFloat()
    .withMessage((value, { req }) =>
      createErrorObj(req, {
        error: ERRORS.TRANSACTION.INPUT.MISSING_REQUIRED_INPUT,
        params: {
          param: "amount",
          value,
          message:
            "The amount of the transaction must be a positive float number",
        },
      })
    )
    .bail(),
  body("amount").customSanitizer((value) => {
    if (value) {
      return Number(value.toFixed(MAXIMUM_FLOAT_PRECISION));
    }
  }),
  body("signature")
    .notEmpty()
    .withMessage((value, { req }) =>
      createErrorObj(req, {
        error: ERRORS.TRANSACTION.INPUT.MISSING_REQUIRED_INPUT,
        params: {
          param: "signature",
          value,
          message: "The signature of the transaction is required",
        },
      })
    )
    .trim()
    .bail(),
  body("sender").optional({ checkFalsy: true, checkNull: true }).trim(),
  body("valid_thru")
    .optional({ checkFalsy: true, checkNull: true })
    .isISO8601()
    .toDate()
    .withMessage((value, { req }) =>
      createErrorObj(req, {
        error: ERRORS.TRANSACTION.INPUT.INCORRECT_INPUT,
        params: {
          param: "valid_thru",
          value,
          message: "The valid_thru date must be in ISO 8601 format",
        },
      })
    )
    .bail(),
  body("supporting_transactions").customSanitizer(() => undefined),
  body("creationDate").customSanitizer(() => undefined),
  body("valid_thru").custom((value, { req }) => {
    if (value &amp;&amp; new Date(value) &lt; new Date())
      return Promise.reject(
        createErrorObj(req, {
          error: ERRORS.TRANSACTION.INPUT.INCORRECT_INPUT,
          params: {
            param: "valid_thru",
            value,
            message:
              "The valid_thru date must be after the transaction creation date",
          },
        })
      );
    return true;
  }),
  body("valid").customSanitizer((value, { req }) => {
    if (
      req.body.pending !== null &amp;&amp;
      req.body.pending !== undefined &amp;&amp;
      (req.body.pending === true || req.body.pending === "true")
    ) {
      return false;
    }
    return value;
  }),
  body("pending").optional({ checkNull: true }).toBoolean(),
  body("valid").optional({ checkNull: true }).toBoolean(),
]);

/**
 * Verifies if a transaction already exists.
 *
 * @post Allows the request to continue if the transaction exists, denies the request otherwise.
 */
const validateExistingTransaction = (
  req,
  res,
  next,
  address,
  shouldExist,
  { location = "body" } = null
) => {
  return validateAssetExistence(
    TYPE.TRANSACTION,
    address,
    shouldExist,
    req,
    res,
    {
      location,
    }
  )
    .then(() => {
      next();
    })
    .catch((callback) => {
      return callback();
    });
};

const verifyPostTransaction = (req, res, next) => {
  const promises = [
    findByAddress(TYPE.USER, req.body.recipient, false, false, res),
  ];
  if (req.body.sender) {
    promises.push(findByAddress(TYPE.USER, req.body.sender, false, false, res));
  }
  return Promise.all(promises).then(([recipientUser, senderUser]) => {
    if (!recipientUser) {
      return createError(req, res, {
        error: ERRORS.USER.INPUT.USER_DOES_NOT_EXIST,
        params: {
          address: req.body.recipient,
          param: "recipient",
          value: req.body.recipient,
        },
      });
    } else if (recipientUser &amp;&amp; recipientUser.active === false) {
      return createError(req, res, {
        error: ERRORS.USER.LOGIC.USER_IS_NOT_ACTIVE,
        params: {
          address: req.body.recipient.address,
          param: "recipient",
          value: req.body.recipient.address,
        },
      });
    } else if (req.body.sender &amp;&amp; !senderUser) {
      return createError(req, res, {
        error: ERRORS.USER.INPUT.USER_DOES_NOT_EXIST,
        params: {
          address: req.body.sender,
          param: "sender",
          value: req.body.sender,
        },
      });
    } else if (senderUser &amp;&amp; senderUser.active === false) {
      return createError(req, res, {
        error: ERRORS.USER.LOGIC.USER_IS_NOT_ACTIVE,
        params: {
          address: req.body.sender,
          param: "sender",
          value: req.body.sender,
        },
      });
    } else if (senderUser) {
      if (
        senderUser.permissions &amp;&amp;
        senderUser.permissions.transfer_to &amp;&amp;
        senderUser.permissions.transfer_to[req.body.recipient] === false
      ) {
        return createError(req, res, {
          error: ERRORS.USER.LOGIC.USER_DOES_NOT_HAVE_TRANSFER_PERMISSIONS,
          params: {
            address: req.body.sender,
            recipient: req.body.recipient,
            param: "sender",
            value: req.body.sender,
          },
        });
      } else {
        if (senderUser.balance &lt; req.body.amount) {
          return createError(req, res, {
            error: ERRORS.USER.INPUT.INSUFFICIENT_FUNDS,
            params: {
              address: req.body.sender,
              param: "amount",
              value: req.body.sender,
            },
          });
        } else if (
          !Array.isArray(senderUser.lastest_transactions) ||
          senderUser.lastest_transactions.length === 0
        ) {
          return createError(req, res, {
            error: ERRORS.USER.INPUT.NO_TRANSACTIONS,
            params: {
              address: req.body.sender,
              param: "sender",
              value: req.body.sender,
            },
          });
        } else {
          let amountToFulfill = req.body.amount;
          let actualBalance = 0;
          let returnedError = false;
          const lastestTxPromises = [];
          (senderUser.lastest_transactions || []).forEach((txid) => {
            lastestTxPromises.push(
              findByAddress(TYPE.TRANSACTION, txid, false, false, res).then(
                (supportingTransaction) => {
                  if (!supportingTransaction) {
                    returnedError = true;
                    return createError(req, res, {
                      error: ERRORS.USER.LOGIC.NONEXISTENT_LASTEST_TRANSACTION,
                      params: {
                        address: req.body.sender,
                        param: "sender",
                        value: req.body.sender,
                        transactionSignature: txid,
                      },
                    });
                  } else if (
                    supportingTransaction.recipient !== req.body.sender
                  ) {
                    returnedError = true;
                    return createError(req, res, {
                      error:
                        ERRORS.USER.LOGIC
                          .INCORRECT_RECIPIENT_LASTEST_TRANSACTION,
                      params: {
                        address: req.body.sender,
                        param: "sender",
                        value: req.body.sender,
                        transactionSignature: txid,
                      },
                    });
                  } else {
                    amountToFulfill -= supportingTransaction.amount;
                    actualBalance += supportingTransaction.amount;
                  }
                }
              )
            );
          });
          return Promise.all(lastestTxPromises).then(() => {
            if (returnedError) {
              return;
            }
            const copyOfAmountToFulfill = amountToFulfill;
            let amountPending = 0;
            const pendingTxPromises = [];

            (senderUser.pending_transactions || []).forEach((txid) => {
              pendingTxPromises.push(
                findByAddress(TYPE.TRANSACTION, txid, false, false, res).then(
                  (pendingTransaction) => {
                    if (!pendingTransaction) {
                      returnedError = true;
                      return createError(req, res, {
                        error:
                          ERRORS.USER.LOGIC.NONEXISTENT_PENDING_TRANSACTION,
                        params: {
                          address: req.body.sender,
                          param: "sender",
                          value: req.body.sender,
                          transactionSignature: txid,
                        },
                      });
                    }
                    if (pendingTransaction.creator === req.body.sender) {
                      amountPending += pendingTransaction.amount;
                      amountToFulfill += pendingTransaction.amount;
                      actualBalance -= pendingTransaction.amount;
                    }
                  }
                )
              );
            });

            return Promise.all(pendingTxPromises).then(() => {
              if (returnedError) {
                return;
              } else {
                if (amountToFulfill > 0) {
                  returnedError = true;
                  if (amountToFulfill !== copyOfAmountToFulfill)
                    return createError(req, res, {
                      error:
                        ERRORS.USER.INPUT
                          .INSUFFICIENT_FUNDS_PENDING_TRANSACTIONS,
                      params: {
                        address: req.body.sender,
                        param: "amount",
                        value: req.body.sender,
                        amountPending,
                        actualBalance,
                      },
                    });
                  else
                    return createError(req, res, {
                      error:
                        ERRORS.USER.INPUT.INSUFFICIENT_FUNDS_UNEXPECTED_BALANCE,
                      params: {
                        address: req.body.sender,
                        param: "amount",
                        value: req.body.sender,
                        actualBalance,
                      },
                    });
                }
              }
              return next();
            });
          });
        }
      }
    } else if (
      recipientUser &amp;&amp;
      recipientUser.permissions &amp;&amp;
      recipientUser.permissions.coinbase !== true
    ) {
      return createError(req, res, {
        error: ERRORS.USER.LOGIC.USER_DOES_NOT_HAVE_PERMISSIONS,
        params: {
          address: req.body.recipient,
          param: "recipient",
          value: req.body.recipient,
          requiredPermission: "coinbase",
        },
      });
    } else {
      return next();
    }
  });
};

/**
 * Verifies if a transaction is pending.
 *
 * @post Allows the request to continue if the transaction is pending, denies the request otherwise.
 */
const validatePendingTransaction = async (req, res, next) => {
  const { address } = req.params;
  return findByAddress(TYPE.TRANSACTION, address, false, false, res).then(
    (transaction) => {
      if (transaction.pending) {
        return next();
      }
      return createError(req, res, {
        error: ERRORS.TRANSACTION.INPUT.TRANSACTION_IS_NOT_PENDING,
        params: {
          signature: req.params.address,
          param: "address",
          value: req.params.address,
        },
      });
    }
  );
};

/**
 * Validation chain of a transaction get/put request
 */
const validateTransactionAddress = [
  (req, res, next) =>
    validateExistingTransaction(req, res, next, req.params.address, true, {
      location: "params",
    }),
];

const validateTransactionSignature = (req, res, next) => {
  if (process.env.DISABLE_INTEGRITY_VALIDATION === "true") return next();
  const { creator, signature } = req.body;
  const transaction = new Transaction(req.body).toSignatureString();
  const expectedPublicKey = getPublicKey(transaction, signature);
  if (expectedPublicKey) {
    return findByAddress(TYPE.USER, creator, false, false, res).then((user) => {
      if (user.public_key !== expectedPublicKey) {
        return createError(req, res, {
          error: ERRORS.TRANSACTION.LOGIC.NON_MATCHING_KEYS,
          params: {
            param: "signature",
            value: req.body.signature,
          },
        });
      }
      return next();
    });
  } else
    return createError(req, res, {
      error: ERRORS.TRANSACTION.LOGIC.DECRYPTING_ERROR,
      params: {
        param: "signature",
        value: req.body.signature,
      },
    });
};

/**
 * Validation chain of a transaction update request
 */
const validateTransactionUpdateRequest = [validatePendingTransaction];
module.exports.validateTransactionAddress = validateTransactionAddress;
module.exports.validateTransactionUpdateRequest = validateTransactionUpdateRequest;
module.exports.verifyPostTransaction = [
  (req, res, next) =>
    validateExistingTransaction(req, res, next, req.body.signature, false, {
      location: "body",
    }),
  verifyPostTransaction,
  validateTransactionSignature,
];
module.exports.inputValidation = inputValidation;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-MongoUtils.html">MongoUtils</a></li></ul><h3>Classes</h3><ul><li><a href="Asset.html">Asset</a></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="Transaction.html">Transaction</a></li><li><a href="User.html">User</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_putAsset">_putAsset</a></li><li><a href="global.html#_updateTransaction">_updateTransaction</a></li><li><a href="global.html#_updateUser">_updateUser</a></li><li><a href="global.html#buildAssetTransaction">buildAssetTransaction</a></li><li><a href="global.html#buildBatch">buildBatch</a></li><li><a href="global.html#createTransaction">createTransaction</a></li><li><a href="global.html#expandSupportingTransactions">expandSupportingTransactions</a></li><li><a href="global.html#findAllAssets">findAllAssets</a></li><li><a href="global.html#findByAddress">findByAddress</a></li><li><a href="global.html#findTransaction">findTransaction</a></li><li><a href="global.html#findUser">findUser</a></li><li><a href="global.html#getAddress">getAddress</a></li><li><a href="global.html#getSupportingTransactions">getSupportingTransactions</a></li><li><a href="global.html#getTransactionAddress">getTransactionAddress</a></li><li><a href="global.html#getTransactionByAddress">getTransactionByAddress</a></li><li><a href="global.html#getTransactions">getTransactions</a></li><li><a href="global.html#getTransferAddress">getTransferAddress</a></li><li><a href="global.html#getUserAddress">getUserAddress</a></li><li><a href="global.html#getUserByAddress">getUserByAddress</a></li><li><a href="global.html#getUsers">getUsers</a></li><li><a href="global.html#hash512">hash512</a></li><li><a href="global.html#http">http</a></li><li><a href="global.html#inputValidation">inputValidation</a></li><li><a href="global.html#normalizePort">normalizePort</a></li><li><a href="global.html#onError">onError</a></li><li><a href="global.html#onListening">onListening</a></li><li><a href="global.html#port">port</a></li><li><a href="global.html#putAsset">putAsset</a></li><li><a href="global.html#putBatch">putBatch</a></li><li><a href="global.html#server">server</a></li><li><a href="global.html#updateTransaction">updateTransaction</a></li><li><a href="global.html#validate">validate</a></li><li><a href="global.html#validateAssetExistence">validateAssetExistence</a></li><li><a href="global.html#validateExistingTransaction">validateExistingTransaction</a></li><li><a href="global.html#validatePendingTransaction">validatePendingTransaction</a></li><li><a href="global.html#validateTransactionAddress">validateTransactionAddress</a></li><li><a href="global.html#validateTransactionUpdateRequest">validateTransactionUpdateRequest</a></li><li><a href="global.html#validateUserCreation">validateUserCreation</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Fri May 07 2021 12:06:04 GMT-0500 (Colombia Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
