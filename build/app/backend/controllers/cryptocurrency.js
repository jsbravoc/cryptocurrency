const{SEVERITY,logFormatted}=require("../utils/logger"),Transaction=require("../models/Transaction"),User=require("../models/User"),{MAXIMUM_FLOAT_PRECISION,TYPE,USER_TYPE,HTTP_METHODS}=require("../utils/constants"),{findAllObjects,findByAddress,getTransactionAddress,getUserAddress,hash512,_putObject,putBatch}=require("./common"),{ERRORS}=require("../utils/errors"),SawtoothTransaction=require("../models/SawtoothTransaction"),createAddress=(t,e=new Date)=>hash512(`${t}${e.getTime()}`),findTransaction=(t,e=!0,n=null)=>findByAddress(TYPE.TRANSACTION,t,e,n),_updateTransaction=t=>_putObject(TYPE.TRANSACTION,HTTP_METHODS.PUT,"PUT [LOCAL] /cryptocurrency",t),getSupportingTransactions=(t,n=null)=>{const{amount:i,recipient:e,sender:s}=t;let r=[];return r.push(findByAddress(TYPE.USER,e,!1,n)),s&&r.push(findByAddress(TYPE.USER,s,!1,n)),Promise.all(r).then(([t,a])=>{if(s){let s=i,r=[];const e=[];return(a.latest_transactions||[]).forEach(t=>e.push(findTransaction(t,!0,n))),Promise.all(e).then(e=>{for(let t=0;t<e.length&&0<s;t+=1){var n=e[t];s-=Number(n.amount),r.push(n)}return s=Number(s.toFixed(MAXIMUM_FLOAT_PRECISION)),{existingSender:a,existingRecipient:t,pendingAmount:s,usedTransactions:r}})}return{pendingAmount:null,usedTransactions:null,existingRecipient:t,existingSender:null}})},expandSupportingTransactions=async(e,n,s=null)=>{if(!n){n={};const t=await findAllObjects(TYPE.TRANSACTION,"GET /cryptocurrency",100,!0,s);t.forEach(t=>{n[t.address]=t})}if(e&&Array.isArray(e.supporting_transactions))for(let t=0;t<e.supporting_transactions.length;t+=1){var r=e.supporting_transactions[t],r="object"==typeof r?r:n[r]||await findTransaction(r,!0,s);r&&Array.isArray(r.supporting_transactions)&&"string"==typeof r.supporting_transactions[0]?e.supporting_transactions[t]=await expandSupportingTransactions(r,n,s):e.supporting_transactions[t]=r}return e},getTransactions=(t,s)=>{const r="true"===t.query.expand||!1,a="true"===t.query.hidePending||!1,i="true"===t.query.hideInvalid||!1,o="true"===t.query.simplifyTransaction||!1;var e=Number.isNaN(Number(t.query.limit))?0:Number(t.query.limit);return findAllObjects(TYPE.TRANSACTION,"GET /cryptocurrency",e,!0,s).then(t=>{if(t=t.sort((t,e)=>new Date(t.creationDate)-new Date(e.creationDate)),a&&(t=t.filter(t=>!t.pending)),i&&(t=t.filter(t=>t.valid)),o)return s.json(t.map(t=>t.toSimplifiedObject()));if(!r)return s.json(t.map(t=>t.toObject()));const e={};t.forEach(t=>{e[t.address]=t});const n=[];t.forEach(t=>n.push(expandSupportingTransactions(t,e,s))),Promise.all(n).then(()=>s.status(200).json(t.map(t=>t.toObject())))}).catch(()=>s.status(ERRORS.SAWTOOTH.UNAVAILABLE.errorCode).json({msg:t.t("MESSAGES.SAWTOOTH_UNAVAILABLE"),error:t.t("MESSAGES.SAWTOOTH_UNAVAILABLE")}))},getTransactionByAddress=(r,a)=>findTransaction(r.params.address,!0,a).then(t=>{var e="true"===r.query.expand||!1,n="true"===r.query.simplifyTransaction||!1;const s="true"===r.query.simplifySupportingTransactions||!1;return n?a.status(200).json(t.toSimplifiedObject()):e?expandSupportingTransactions(t,void 0,a).then(()=>(s&&t.supporting_transactions.forEach(t=>t.toSimplifiedObject()),a.status(200).json(t))):a.status(200).json(t)}),createTransaction=(t,e,{disableSender:n=!1,disableRecipient:s=!1}=null)=>{const r=new Transaction(t.body);var{signature:a,creationDate:i}=r,i=createAddress(a,i);return r.address=i,putTransaction(r,HTTP_METHODS.POST,{disableSender:n||!1,disableRecipient:s||!1},t,e)},updateTransaction=(n,s)=>{let t;return n.query.approve&&(t="true"===n.query.approve||!1),findTransaction(n.params.address,!1,s).then(e=>(n.body.description&&(e.description=n.body.description),void 0===t?_updateTransaction(e).then(({responseCode:t})=>(delete e.type,s.status(t).json({msg:n.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.UPDATE"),payload:e}))):(e.valid=t,e.pending=!1,putTransaction(e,HTTP_METHODS.PUT,{disableSender:!1,disableRecipient:!1},n,s))))},putTransaction=(u,p=HTTP_METHODS.POST,t={disableRecipient:!1,disableSender:!1},S,l)=>{const{amount:E,address:A,sender:g,recipient:m,valid:y}=u,{disableRecipient:h,disableSender:O}=t;let P,f,R,_;return getSupportingTransactions(u,l).then(({pendingAmount:t,usedTransactions:s,existingRecipient:e,existingSender:r})=>{let n=new User(e);h&&(n.active=!1),p===HTTP_METHODS.PUT&&n.removePendingTransaction(A);const a=[];y&&(s||[]).forEach(t=>{u.addSupportingTransaction(t.address),a.push(getTransactionAddress(t.address))}),n.addTransaction(USER_TYPE.RECIPIENT,E,A,y),n=n.toString(!1,HTTP_METHODS.PUT),R=getUserAddress(m);e=n,e=new SawtoothTransaction({inputs:[R],outputs:[R],payload:e});if(r){let n=new User(r);if(O&&(n.active=!1),p===HTTP_METHODS.PUT&&n.removePendingTransaction(A),y){Array.isArray(s)&&s.forEach(t=>n.addTransaction(USER_TYPE.SENDER,t.amount,t.address,y));r=-t;if(0<r){var i=S.t("MESSAGES.CHANGE_TRANSACTION_DESCRIPTION",{signature:u.address,input:-t+E,amount:E,change:r});const c=new Date;c.setMilliseconds(c.getMilliseconds()+1);let e=new Transaction({amount:r,recipient:g,description:i,signature:u.signature,address:createAddress(u.signature,c)});Array.isArray(s)&&s.forEach(t=>e.addSupportingTransaction(t.address)),n.addTransaction(USER_TYPE.RECIPIENT,e.amount,e.address);var o=getTransactionAddress(e.address);e=e.toString(!1,HTTP_METHODS.POST);i=e;P={inputs:[o,...a,getUserAddress(g)],outputs:[o],payload:i}}}else n.addTransaction(USER_TYPE.SENDER,E,A,y);n=n.toString(!1,HTTP_METHODS.PUT),_=getUserAddress(g);o=n;f=new SawtoothTransaction({inputs:[_],outputs:[_],payload:o})}i=getTransactionAddress(u.address),o=u.toString(!1,p);const d=new SawtoothTransaction({inputs:[i,...a],outputs:[i],payload:o});e&&d.inputs.push(R),f&&d.inputs.push(_);const T=[{...d}];return e&&T.push({...e}),f&&T.push({...f}),P&&T.push({...P}),putBatch(p,`${p} /cryptocurrency`,T).then(({responseCode:t})=>(delete u.type,delete u.httpMethod,l.status(t).json({msg:p===HTTP_METHODS.POST?S.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.CREATION"):S.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.UPDATE"),payload:u})))})};module.exports.createAddress=createAddress,module.exports.findTransaction=findTransaction,module.exports.getSupportingTransactions=getSupportingTransactions,module.exports.expandSupportingTransactions=expandSupportingTransactions,module.exports.getTransactions=getTransactions,module.exports.getTransactionByAddress=getTransactionByAddress,module.exports.createTransaction=createTransaction,module.exports.updateTransaction=updateTransaction;