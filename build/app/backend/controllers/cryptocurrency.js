const{SEVERITY,logFormatted}=require("../utils/logger"),Transaction=require("../models/Transaction"),User=require("../models/User"),{MAXIMUM_FLOAT_PRECISION,TYPE,USER_TYPE,HTTP_METHODS}=require("../utils/constants"),{findAllObjects,findByAddress,getTransactionAddress,getUserAddress,hash512,_putObject,putBatch}=require("./common"),{ERRORS}=require("../utils/errors"),createAddress=(e,t=new Date)=>hash512(`${e}${t.getTime()}`),findTransaction=(e,t=!0,n=null)=>findByAddress(TYPE.TRANSACTION,e,t,n),_updateTransaction=e=>_putObject(TYPE.TRANSACTION,HTTP_METHODS.PUT,"PUT [LOCAL] /cryptocurrency",e),getSupportingTransactions=(e,n=null)=>{const{amount:i,recipient:t,sender:r}=e;let s=[];return s.push(findByAddress(TYPE.USER,t,!1,n)),r&&s.push(findByAddress(TYPE.USER,r,!1,n)),Promise.all(s).then(([e,a])=>{if(r){let r=i,s=[];const t=[];return(a.latest_transactions||[]).forEach(e=>t.push(findTransaction(e,!0,n))),Promise.all(t).then(t=>{for(let e=0;e<t.length&&0<r;e+=1){var n=t[e];r-=Number(n.amount),s.push(n)}return r=Number(r.toFixed(MAXIMUM_FLOAT_PRECISION)),{existingSender:a,existingRecipient:e,pendingAmount:r,usedTransactions:s}})}return{pendingAmount:null,usedTransactions:null,existingRecipient:e,existingSender:null}})},expandSupportingTransactions=async(t,n,r=null)=>{if(!n){n={};const e=await findAllObjects(TYPE.TRANSACTION,"GET /cryptocurrency",100,!0,r);e.forEach(e=>{n[e.address]=e})}if(t&&Array.isArray(t.supporting_transactions))for(let e=0;e<t.supporting_transactions.length;e+=1){var s=t.supporting_transactions[e],s="object"==typeof s?s:n[s]||await findTransaction(s,!0,r);s&&Array.isArray(s.supporting_transactions)&&"string"==typeof s.supporting_transactions[0]?t.supporting_transactions[e]=await expandSupportingTransactions(s,n,r):t.supporting_transactions[e]=s}return t},getTransactions=(e,r)=>{const s="true"===e.query.expand||!1,a="true"===e.query.hidePending||!1,i="true"===e.query.hideInvalid||!1,o="true"===e.query.simplifyTransaction||!1;var t=Number.isNaN(Number(e.query.limit))?0:Number(e.query.limit);return findAllObjects(TYPE.TRANSACTION,"GET /cryptocurrency",t,!0,r).then(e=>{if(e=e.sort((e,t)=>new Date(e.creationDate)-new Date(t.creationDate)),a&&(e=e.filter(e=>!e.pending)),i&&(e=e.filter(e=>e.valid)),o)return r.json(e.map(e=>e.toSimplifiedObject()));if(!s)return r.json(e.map(e=>e.toObject()));const t={};e.forEach(e=>{t[e.address]=e});const n=[];e.forEach(e=>n.push(expandSupportingTransactions(e,t,r))),Promise.all(n).then(()=>r.status(200).json(e.map(e=>e.toObject())))}).catch(()=>r.status(ERRORS.SAWTOOTH.UNAVAILABLE.errorCode).json({msg:e.t("MESSAGES.SAWTOOTH_UNAVAILABLE"),error:e.t("MESSAGES.SAWTOOTH_UNAVAILABLE")}))},getTransactionByAddress=(s,a)=>findTransaction(s.params.address,!0,a).then(e=>{var t="true"===s.query.expand||!1,n="true"===s.query.simplifyTransaction||!1;const r="true"===s.query.simplifySupportingTransactions||!1;return n?a.status(200).json(e.toSimplifiedObject()):t?expandSupportingTransactions(e,void 0,a).then(()=>(r&&e.supporting_transactions.forEach(e=>e.toSimplifiedObject()),a.status(200).json(e))):a.status(200).json(e)}),createTransaction=(e,t,{disableSender:n=!1,disableRecipient:r=!1}=null)=>{const s=new Transaction(e.body);var{sender:a,recipient:i,amount:o,valid:d}=s,{signature:c,creationDate:u}=s,u=createAddress(c,u);return s.address=u,createTransactionPayload(s,o,u,a,i,d,HTTP_METHODS.POST,{disableSender:n||!1,disableRecipient:r||!1},e,t)},updateTransaction=(i,o)=>{let d;return i.query.approve&&(d="true"===i.query.approve||!1),findTransaction(i.params.address,!1,o).then(t=>{if(i.body.description&&(t.description=i.body.description),void 0===d)return _updateTransaction(t).then(({responseCode:e})=>(delete t.type,o.status(e).json({msg:i.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.UPDATE"),payload:t})));t.valid=d,t.pending=!1;var{sender:e,recipient:n,amount:r,address:s,valid:a}=t;return createTransactionPayload(t,r,s,e,n,a,HTTP_METHODS.PUT,{disableSender:!1,disableRecipient:!1},i,o)})},createTransactionPayload=(T,p,S,l,E,A,g=HTTP_METHODS.POST,e={disableRecipient:!1,disableSender:!1},y,m)=>{const{disableRecipient:P,disableSender:O}=e;let f,h,R,_;return getSupportingTransactions(T,m).then(({pendingAmount:e,usedTransactions:r,existingRecipient:t,existingSender:s})=>{let n=new User(t);P&&(n.active=!1),g===HTTP_METHODS.PUT&&n.removePendingTransaction(S);const a=[];A&&(r||[]).forEach(e=>{T.addSupportingTransaction(e.address),a.push(getTransactionAddress(e.address))}),n.addTransaction(USER_TYPE.RECIPIENT,p,S,A),n=n.toString(!1,HTTP_METHODS.PUT),R=getUserAddress(E);t=n,t={inputs:[R],outputs:[R],payload:t};if(s){let n=new User(s);if(O&&(n.active=!1),g===HTTP_METHODS.PUT&&n.removePendingTransaction(S),A){Array.isArray(r)&&r.forEach(e=>n.addTransaction(USER_TYPE.SENDER,e.amount,e.address,A));s=-e;if(0<s){var i=y.t("MESSAGES.CHANGE_TRANSACTION_DESCRIPTION",{signature:T.address,input:-e+p,amount:p,change:s});const u=new Date;u.setMilliseconds(u.getMilliseconds()+1);let t=new Transaction({amount:s,recipient:l,description:i,signature:T.signature,address:createAddress(T.signature,u)});Array.isArray(r)&&r.forEach(e=>t.addSupportingTransaction(e.address)),n.addTransaction(USER_TYPE.RECIPIENT,t.amount,t.address);var o=getTransactionAddress(t.address);t=t.toString(!1,HTTP_METHODS.POST);i=t;f={inputs:[o,...a,getUserAddress(l)],outputs:[o],payload:i}}}else n.addTransaction(USER_TYPE.SENDER,p,S,A);n=n.toString(!1,HTTP_METHODS.PUT),_=getUserAddress(l);o=n;h={inputs:[_],outputs:[_],payload:o}}i=getTransactionAddress(T.address),o=T.toString(!1,g);const d={inputs:[i,...a],outputs:[i],payload:o};d.inputs.push(R),h&&d.inputs.push(_);const c=[{...d}];return c.push({...t}),h&&c.push({...h}),f&&c.push({...f}),putBatch(g,`${g} /cryptocurrency`,c).then(({responseCode:e})=>(delete T.type,delete T.httpMethod,m.status(e).json({msg:g===HTTP_METHODS.POST?y.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.CREATION"):y.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.UPDATE"),payload:T})))})};module.exports.createAddress=createAddress,module.exports.findTransaction=findTransaction,module.exports.getSupportingTransactions=getSupportingTransactions,module.exports.expandSupportingTransactions=expandSupportingTransactions,module.exports.getTransactions=getTransactions,module.exports.getTransactionByAddress=getTransactionByAddress,module.exports.createTransaction=createTransaction,module.exports.updateTransaction=updateTransaction;