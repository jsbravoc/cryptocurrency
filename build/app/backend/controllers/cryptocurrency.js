const{SEVERITY,logFormatted}=require("../utils/logger"),Transaction=require("../models/Transaction"),User=require("../models/User"),{MAXIMUM_FLOAT_PRECISION,TYPE,USER_TYPE,HTTP_METHODS}=require("../utils/constants"),{findAllAssets,findByAddress,getTransactionAddress,getUserAddress,hash512,_putAsset,putBatch}=require("./common"),{ERRORS}=require("../utils/errors"),createAddress=(e,t=new Date)=>hash512(`${e}${t.getTime()}`),findTransaction=(e,t=!0,n=null)=>findByAddress(TYPE.TRANSACTION,e,t,n),_updateTransaction=e=>_putAsset(TYPE.TRANSACTION,HTTP_METHODS.PUT,"PUT [LOCAL] /cryptocurrency",e),getSupportingTransactions=(e,n=null)=>{const{amount:i,recipient:t,sender:s}=e;let r=[];return r.push(findByAddress(TYPE.USER,t,!1,n)),s&&r.push(findByAddress(TYPE.USER,s,!1,n)),Promise.all(r).then(([e,a])=>{if(s){let s=i,r=[];const t=[];return(a.latest_transactions||[]).forEach(e=>t.push(findTransaction(e,!0,n))),Promise.all(t).then(t=>{for(let e=0;e<t.length&&0<s;e+=1){var n=t[e];s-=Number(n.amount),r.push(n)}return s=Number(s.toFixed(MAXIMUM_FLOAT_PRECISION)),{existingSender:a,existingRecipient:e,pendingAmount:s,usedTransactions:r}})}return{pendingAmount:null,usedTransactions:null,existingRecipient:e,existingSender:null}})},expandSupportingTransactions=async(t,n,s=null)=>{if(!n){n={};const e=await findAllAssets(TYPE.TRANSACTION,"GET /cryptocurrency",100,!0,s);e.forEach(e=>{n[e.address]=e})}if(t&&Array.isArray(t.supporting_transactions))for(let e=0;e<t.supporting_transactions.length;e+=1){var r=t.supporting_transactions[e],r="object"==typeof r?r:n[r]||await findTransaction(r,!0,s);r&&Array.isArray(r.supporting_transactions)&&"string"==typeof r.supporting_transactions[0]?t.supporting_transactions[e]=await expandSupportingTransactions(r,n,s):t.supporting_transactions[e]=r}return t},getTransactions=(e,s)=>{const r="true"===e.query.expand||!1,a="true"===e.query.hidePending||!1,i="true"===e.query.hideInvalid||!1,o="true"===e.query.simplifyTransaction||!1;var t=Number.isNaN(Number(e.query.limit))?0:Number(e.query.limit);return findAllAssets(TYPE.TRANSACTION,"GET /cryptocurrency",t,!0,s).then(e=>{if(e=e.sort((e,t)=>new Date(e.creationDate)-new Date(t.creationDate)),a&&(e=e.filter(e=>!e.pending)),i&&(e=e.filter(e=>e.valid)),o)return s.json(e.map(e=>e.toSimplifiedObject()));if(!r)return s.json(e.map(e=>e.toObject()));const t={};e.forEach(e=>{t[e.address]=e});const n=[];e.forEach(e=>n.push(expandSupportingTransactions(e,t,s))),Promise.all(n).then(()=>s.status(200).json(e.map(e=>e.toObject())))}).catch(()=>s.status(ERRORS.SAWTOOTH.UNAVAILABLE.errorCode).json({msg:e.t("MESSAGES.SAWTOOTH_UNAVAILABLE"),error:e.t("MESSAGES.SAWTOOTH_UNAVAILABLE")}))},getTransactionByAddress=(r,a)=>findTransaction(r.params.address,!0,a).then(e=>{var t="true"===r.query.expand||!1,n="true"===r.query.simplifyTransaction||!1;const s="true"===r.query.simplifySupportingTransactions||!1;return n?a.status(200).json(e.toSimplifiedObject()):t?expandSupportingTransactions(e,void 0,a).then(()=>(s&&e.supporting_transactions.forEach(e=>e.toSimplifiedObject()),a.status(200).json(e))):a.status(200).json(e)}),createTransaction=(e,t,{disableSender:n=!1,disableRecipient:s=!1}=null)=>{const r=new Transaction(e.body);var{sender:a,recipient:i,amount:o,valid:d}=r,{signature:u,creationDate:T}=r,T=createAddress(u,T);return r.address=T,createTransactionPayload(r,o,T,a,i,d,HTTP_METHODS.POST,{disableSender:n||!1,disableRecipient:s||!1},e,t)},updateTransaction=(i,o)=>{let d;return i.query.approve&&(d="true"===i.query.approve||!1),findTransaction(i.params.address,!1,o).then(t=>{if(i.body.description&&(t.description=i.body.description),void 0===d)return _updateTransaction(t).then(({responseCode:e})=>(delete t.type,o.status(e).json({msg:i.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.UPDATE"),payload:t})));t.valid=d,t.pending=!1;var{sender:e,recipient:n,amount:s,address:r,valid:a}=t;return createTransactionPayload(t,s,r,e,n,a,HTTP_METHODS.PUT,{disableSender:!1,disableRecipient:!1},i,o)})},createTransactionPayload=(c,p,S,l,E,A,g=HTTP_METHODS.POST,e={disableRecipient:!1,disableSender:!1},y,m)=>{const{disableRecipient:P,disableSender:f}=e;let h,O,R,_;return getSupportingTransactions(c,m).then(({pendingAmount:e,usedTransactions:s,existingRecipient:t,existingSender:r})=>{let n=new User(t);P&&(n.active=!1),g===HTTP_METHODS.PUT&&n.removePendingTransaction(S);const a=[];A&&(s||[]).forEach(e=>{c.addSupportingTransaction(e.address),a.push(getTransactionAddress(e.address))}),n.addTransaction(USER_TYPE.RECIPIENT,p,S,A),n=n.toString(!1,HTTP_METHODS.PUT),R=getUserAddress(E);t=n,t={inputs:[R],outputs:[R],payload:t};if(r){let n=new User(r);if(f&&(n.active=!1),g===HTTP_METHODS.PUT&&n.removePendingTransaction(S),A){Array.isArray(s)&&s.forEach(e=>n.addTransaction(USER_TYPE.SENDER,e.amount,e.address,A));r=-e;if(0<r){var i=y.t("MESSAGES.CHANGE_TRANSACTION_DESCRIPTION",{signature:c.address,input:-e+p,amount:p,change:r});const T=new Date;T.setMilliseconds(T.getMilliseconds()+1);let t=new Transaction({amount:r,recipient:l,description:i,signature:c.signature,address:createAddress(c.signature,T)});Array.isArray(s)&&s.forEach(e=>t.addSupportingTransaction(e.address)),n.addTransaction(USER_TYPE.RECIPIENT,t.amount,t.address);var o=getTransactionAddress(t.address);t=t.toString(!1,HTTP_METHODS.POST);i=t;h={inputs:[o,...a,getUserAddress(l)],outputs:[o],payload:i}}}else n.addTransaction(USER_TYPE.SENDER,p,S,A);n=n.toString(!1,HTTP_METHODS.PUT),_=getUserAddress(l);o=n;O={inputs:[_],outputs:[_],payload:o}}i=getTransactionAddress(c.address),o=c.toString(!1,g);const d={inputs:[i,...a],outputs:[i],payload:o};d.inputs.push(R),O&&d.inputs.push(_);const u=[{...d}];return u.push({...t}),O&&u.push({...O}),h&&u.push({...h}),putBatch(g,`${g} /cryptocurrency`,u).then(({responseCode:e})=>(delete c.type,delete c.httpMethod,m.status(e).json({msg:g===HTTP_METHODS.POST?y.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.CREATION"):y.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.UPDATE"),payload:c})))})};module.exports.createAddress=createAddress,module.exports.findTransaction=findTransaction,module.exports.getSupportingTransactions=getSupportingTransactions,module.exports.expandSupportingTransactions=expandSupportingTransactions,module.exports.getTransactions=getTransactions,module.exports.getTransactionByAddress=getTransactionByAddress,module.exports.createTransaction=createTransaction,module.exports.updateTransaction=updateTransaction;