const{SEVERITY,logFormatted}=require("../utils/logger"),Transaction=require("../models/Transaction"),User=require("../models/User"),{MAXIMUM_FLOAT_PRECISION,TYPE,USER_TYPE,HTTP_METHODS}=require("../utils/constants"),{findAllAssets,findByAddress,getTransactionAddress,getUserAddress,hash512,_putAsset,putBatch}=require("./common"),{ERRORS}=require("../utils/errors"),createSignature=(t,n=new Date)=>hash512(`${t}${n.getTime()}`),findTransaction=(t,n=!1,e=!0,r=null)=>findByAddress(TYPE.TRANSACTION,t,n,e,r),_updateTransaction=t=>_putAsset(TYPE.TRANSACTION,HTTP_METHODS.PUT,"PUT [LOCAL] /cryptocurrency",t),getSupportingTransactions=(t,e=null)=>{const{amount:i,recipient:n,sender:r}=t;let a=[];return a.push(findByAddress(TYPE.USER,n,!1,!1,e)),r&&a.push(findByAddress(TYPE.USER,r,!1,!1,e)),Promise.all(a).then(([t,s])=>{if(r){let r=i,a=[];const n=[];return(s.latest_transactions||[]).forEach(t=>n.push(findTransaction(t,!1,!0,e))),Promise.all(n).then(n=>{for(let t=0;t<n.length&&0<r;t+=1){var e=n[t];r-=Number(e.amount),a.push(e)}return r=Number(r.toFixed(MAXIMUM_FLOAT_PRECISION)),{existingSender:s,existingRecipient:t,pendingAmount:r,usedTransactions:a}})}return{pendingAmount:null,usedTransactions:null,existingRecipient:t,existingSender:null}})},expandSupportingTransactions=async(n,e,r=null)=>{if(!e){e={};const t=await findAllAssets(TYPE.TRANSACTION,"GET /cryptocurrency");t.forEach(t=>{e[t.signature]=t})}if(n&&Array.isArray(n.supporting_transactions))for(let t=0;t<n.supporting_transactions.length;t+=1){var a=n.supporting_transactions[t],a="object"==typeof a?a:e[a]||await findTransaction(a,!1,!0,r);a&&Array.isArray(a.supporting_transactions)&&"string"==typeof a.supporting_transactions[0]?n.supporting_transactions[t]=await expandSupportingTransactions(a,e,r):n.supporting_transactions[t]=a}return n},getTransactions=(t,r)=>{const a="true"===t.query.expanded||!1,s="true"===t.query.hidePending||!1,i="true"===t.query.hideInvalid||!1;var n=Number.isNaN(Number(t.query.limit))?0:Number(t.query.limit);return findAllAssets(TYPE.TRANSACTION,"GET /cryptocurrency",n,!1,!0,r).then(t=>{if(t=t.sort((t,n)=>new Date(t.creationDate)-new Date(n.creationDate)),s&&(t=t.filter(t=>!t.pending)),i&&(t=t.filter(t=>t.valid)),!a)return r.json(t.map(t=>t.toObject()));const n={};t.forEach(t=>{n[t.signature]=t});const e=[];t.forEach(t=>e.push(expandSupportingTransactions(t,n,r))),Promise.all(e).then(()=>r.status(200).json(t.map(t=>t.toObject())))}).catch(()=>r.status(ERRORS.SAWTOOTH.UNAVAILABLE.errorCode).json({msg:t.t("MESSAGES.SAWTOOTH_UNAVAILABLE"),error:t.t("MESSAGES.SAWTOOTH_UNAVAILABLE")}))},getTransactionByAddress=(n,e)=>findTransaction(n.params.address,!1,!0,e).then(t=>{return"true"!==n.query.expanded?e.status(200).json(t):expandSupportingTransactions(t,void 0,e).then(()=>e.status(200).json(t))}),createTransaction=(t,n,{disableSender:e=!1,disableRecipient:r=!1}=null)=>{const a=new Transaction(t.body);var{sender:s,recipient:i,amount:o,valid:u}=a,{signature:d}=a,d=createSignature(d,a.creationDate);return a.signature=d,createTransactionPayload(a,o,d,s,i,u,HTTP_METHODS.POST,{disableSender:e||!1,disableRecipient:r||!1},t,n)},updateTransaction=(i,o)=>{let u;return i.query.approve&&(u="true"===i.query.approve||!1),findTransaction(i.params.address,!1,!1,o).then(n=>{if(i.body.description&&(n.description=i.body.description),void 0===u)return _updateTransaction(n).then(({responseCode:t})=>(delete n.type,o.status(t).json({msg:i.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.UPDATE"),payload:n})));n.valid=u,n.pending=!1;var{sender:t,recipient:e,amount:r,signature:a,valid:s}=n;return createTransactionPayload(n,r,a,t,e,s,HTTP_METHODS.PUT,{disableSender:!1,disableRecipient:!1},i,o)})},createTransactionPayload=(d,c,T,p,S,g,l="POST",t={disableRecipient:!1,disableSender:!1},E,A)=>{const{disableRecipient:y,disableSender:f}=t;let m,P;return getSupportingTransactions(d,A).then(({pendingAmount:t,usedTransactions:r,existingRecipient:n,existingSender:a})=>{let e=new User(n);y&&(e.active=!1),l===HTTP_METHODS.PUT&&e.removePendingTransaction(T);const s=[];g&&(r||[]).forEach(t=>{d.addSupportingTransaction(t.signature),s.push(getTransactionAddress(t.signature))}),e.addTransaction(USER_TYPE.RECIPIENT,c,T,g),e=e.toString(!1,!1);n=getUserAddress(S),n={inputs:[n],outputs:[n],payload:JSON.stringify({func:"post",args:{transaction:e,txid:S}})};if(a){let e=new User(a);if(f&&(e.active=!1),l===HTTP_METHODS.PUT&&e.removePendingTransaction(T),g){Array.isArray(r)&&r.forEach(t=>e.addTransaction(USER_TYPE.SENDER,t.amount,t.signature,g));a=-t;if(0<a){var i=E.t("MESSAGES.CHANGE_TRANSACTION_DESCRIPTION",{signature:d.signature,input:-t+c,amount:c,change:a}),o=hash512(`changeof:${d.signature}`);let n=new Transaction({amount:a,recipient:p,description:i,signature:o});Array.isArray(r)&&r.forEach(t=>n.addSupportingTransaction(t.signature)),e.addTransaction(USER_TYPE.RECIPIENT,n.amount,n.signature),n=n.toString(!1,!1);i=getTransactionAddress(o),o=JSON.stringify({func:"post",args:{transaction:n,txid:o}});m={inputs:[i,...s],outputs:[i],payload:o}}}e.addTransaction(USER_TYPE.RECIPIENT,c,T,g),e=e.toString(!1,!1);i=getUserAddress(p),o=JSON.stringify({func:"post",args:{transaction:e,txid:p}});P={inputs:[i],outputs:[i],payload:o}}i=getTransactionAddress(d.signature),o=JSON.stringify({func:"post",args:{transaction:d.toString(!1,!1),txid:d.signature}});const u=[{...{inputs:[i,...s],outputs:[i],payload:o}}];return u.push({...n}),P&&u.push({...P}),m&&u.push({...m}),putBatch(l,`${l} /cryptocurrency`,u).then(({responseCode:t})=>(delete d.type,A.status(t).json({msg:l===HTTP_METHODS.POST?E.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.CREATION"):E.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.UPDATE"),payload:d})))})};module.exports.createSignature=createSignature,module.exports.findTransaction=findTransaction,module.exports.getSupportingTransactions=getSupportingTransactions,module.exports.expandSupportingTransactions=expandSupportingTransactions,module.exports.getTransactions=getTransactions,module.exports.getTransactionByAddress=getTransactionByAddress,module.exports.createTransaction=createTransaction,module.exports.updateTransaction=updateTransaction;