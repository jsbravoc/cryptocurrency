const{SEVERITY,logFormatted}=require("../utils/logger"),Transaction=require("../models/Transaction"),User=require("../models/User"),{MAXIMUM_FLOAT_PRECISION,TYPE,USER_TYPE,HTTP_METHODS}=require("../utils/constants"),{findAllAssets,findByAddress,getTransactionAddress,getUserAddress,hash512,_putAsset,putBatch}=require("./common"),{ERRORS}=require("../utils/errors"),createAddress=(e,t=new Date)=>hash512(`${e}${t.getTime()}`),findTransaction=(e,t=!0,n=null)=>findByAddress(TYPE.TRANSACTION,e,t,n),_updateTransaction=e=>_putAsset(TYPE.TRANSACTION,HTTP_METHODS.PUT,"PUT [LOCAL] /cryptocurrency",e),getSupportingTransactions=(e,n=null)=>{const{amount:i,recipient:t,sender:s}=e;let r=[];return r.push(findByAddress(TYPE.USER,t,!1,n)),s&&r.push(findByAddress(TYPE.USER,s,!1,n)),Promise.all(r).then(([e,a])=>{if(s){let s=i,r=[];const t=[];return(a.latest_transactions||[]).forEach(e=>t.push(findTransaction(e,!0,n))),Promise.all(t).then(t=>{for(let e=0;e<t.length&&0<s;e+=1){var n=t[e];s-=Number(n.amount),r.push(n)}return s=Number(s.toFixed(MAXIMUM_FLOAT_PRECISION)),{existingSender:a,existingRecipient:e,pendingAmount:s,usedTransactions:r}})}return{pendingAmount:null,usedTransactions:null,existingRecipient:e,existingSender:null}})},expandSupportingTransactions=async(t,n,s=null)=>{if(!n){n={};const e=await findAllAssets(TYPE.TRANSACTION,"GET /cryptocurrency",100,!0,s);e.forEach(e=>{n[e.address]=e})}if(t&&Array.isArray(t.supporting_transactions))for(let e=0;e<t.supporting_transactions.length;e+=1){var r=t.supporting_transactions[e],r="object"==typeof r?r:n[r]||await findTransaction(r,!0,s);r&&Array.isArray(r.supporting_transactions)&&"string"==typeof r.supporting_transactions[0]?t.supporting_transactions[e]=await expandSupportingTransactions(r,n,s):t.supporting_transactions[e]=r}return t},getTransactions=(e,s)=>{const r="true"===e.query.expanded||!1,a="true"===e.query.hidePending||!1,i="true"===e.query.hideInvalid||!1;var t=Number.isNaN(Number(e.query.limit))?0:Number(e.query.limit);return findAllAssets(TYPE.TRANSACTION,"GET /cryptocurrency",t,!0,s).then(e=>{if(e=e.sort((e,t)=>new Date(e.creationDate)-new Date(t.creationDate)),a&&(e=e.filter(e=>!e.pending)),i&&(e=e.filter(e=>e.valid)),!r)return s.json(e.map(e=>e.toObject()));const t={};e.forEach(e=>{t[e.address]=e});const n=[];e.forEach(e=>n.push(expandSupportingTransactions(e,t,s))),Promise.all(n).then(()=>s.status(200).json(e.map(e=>e.toObject())))}).catch(()=>s.status(ERRORS.SAWTOOTH.UNAVAILABLE.errorCode).json({msg:e.t("MESSAGES.SAWTOOTH_UNAVAILABLE"),error:e.t("MESSAGES.SAWTOOTH_UNAVAILABLE")}))},getTransactionByAddress=(t,n)=>findTransaction(t.params.address,!0,n).then(e=>{return"true"!==t.query.expanded?n.status(200).json(e):expandSupportingTransactions(e,void 0,n).then(()=>n.status(200).json(e))}),createTransaction=(e,t,{disableSender:n=!1,disableRecipient:s=!1}=null)=>{const r=new Transaction(e.body);var{sender:a,recipient:i,amount:o,valid:d}=r,{signature:T,creationDate:u}=r,u=createAddress(T,u);return r.address=u,createTransactionPayload(r,o,u,a,i,d,HTTP_METHODS.POST,{disableSender:n||!1,disableRecipient:s||!1},e,t)},updateTransaction=(i,o)=>{let d;return i.query.approve&&(d="true"===i.query.approve||!1),findTransaction(i.params.address,!1,o).then(t=>{if(i.body.description&&(t.description=i.body.description),void 0===d)return _updateTransaction(t).then(({responseCode:e})=>(delete t.type,o.status(e).json({msg:i.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.UPDATE"),payload:t})));t.valid=d,t.pending=!1;var{sender:e,recipient:n,amount:s,address:r,valid:a}=t;return createTransactionPayload(t,s,r,e,n,a,HTTP_METHODS.PUT,{disableSender:!1,disableRecipient:!1},i,o)})},createTransactionPayload=(c,p,S,l,A,E,g="POST",e={disableRecipient:!1,disableSender:!1},P,y)=>{const{disableRecipient:m,disableSender:h}=e;let O,R,_,U;return getSupportingTransactions(c,y).then(({pendingAmount:e,usedTransactions:s,existingRecipient:t,existingSender:r})=>{let n=new User(t);m&&(n.active=!1),g===HTTP_METHODS.PUT&&n.removePendingTransaction(S);const a=[];E&&(s||[]).forEach(e=>{c.addSupportingTransaction(e.address),a.push(getTransactionAddress(e.address))}),n.addTransaction(USER_TYPE.RECIPIENT,p,S,E),n=n.toString(!1,HTTP_METHODS.PUT),_=getUserAddress(A);t=n,t={inputs:[_],outputs:[_],payload:t};if(r){let n=new User(r);if(h&&(n.active=!1),g===HTTP_METHODS.PUT&&n.removePendingTransaction(S),E){Array.isArray(s)&&s.forEach(e=>n.addTransaction(USER_TYPE.SENDER,e.amount,e.address,E));r=-e;if(0<r){var i=P.t("MESSAGES.CHANGE_TRANSACTION_DESCRIPTION",{signature:c.address,input:-e+p,amount:p,change:r});const u=new Date;u.setMilliseconds(u.getMilliseconds()+1);let t=new Transaction({amount:r,recipient:l,description:i,signature:c.signature,address:createAddress(c.signature,u)});Array.isArray(s)&&s.forEach(e=>t.addSupportingTransaction(e.address)),n.addTransaction(USER_TYPE.RECIPIENT,t.amount,t.address);var o=getTransactionAddress(t.address);t=t.toString(!1,HTTP_METHODS.POST);i=t;O={inputs:[o,...a,getUserAddress(l)],outputs:[o],payload:i}}}else n.addTransaction(USER_TYPE.SENDER,p,S,E);n=n.toString(!1,HTTP_METHODS.PUT),U=getUserAddress(l);o=n;R={inputs:[U],outputs:[U],payload:o}}i=getTransactionAddress(c.address),o=c.toString(!1,HTTP_METHODS.POST);const d={inputs:[i,...a],outputs:[i],payload:o};d.inputs.push(_),R&&d.inputs.push(U);const T=[{...d}];return T.push({...t}),R&&T.push({...R}),O&&T.push({...O}),putBatch(g,`${g} /cryptocurrency`,T).then(({responseCode:e})=>(delete c.type,delete c.httpMethod,y.status(e).json({msg:g===HTTP_METHODS.POST?P.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.CREATION"):P.t("MESSAGES.SUCCESSFUL_REQUEST.TRANSACTION.UPDATE"),payload:c})))})};module.exports.createAddress=createAddress,module.exports.findTransaction=findTransaction,module.exports.getSupportingTransactions=getSupportingTransactions,module.exports.expandSupportingTransactions=expandSupportingTransactions,module.exports.getTransactions=getTransactions,module.exports.getTransactionByAddress=getTransactionByAddress,module.exports.createTransaction=createTransaction,module.exports.updateTransaction=updateTransaction;