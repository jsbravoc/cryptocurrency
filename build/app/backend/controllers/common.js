const _=require("lodash"),crypto=require("crypto"),{default:axios}=require("axios"),{ADDRESS_PREFIX,HTTP_METHODS,TYPE,TRANSACTION_FAMILY}=require("../utils/constants"),{SEVERITY,logFormatted}=require("../utils/logger"),{queryState,sendBatch}=require("../sawtooth/sawtooth_controller"),Transaction=require("../models/Transaction"),User=require("../models/User"),SawtoothTransaction=require("../models/SawtoothTransaction"),cacheManager=require("cache-manager"),redisStore=require("cache-manager-redis");let redisCache;redisCache="true"===process.env.USE_REDIS&&void 0!==process.env.REDIS_HOST&&void 0!==process.env.REDIS_PORT?cacheManager.caching({store:redisStore,host:process.env.REDIS_HOST,port:process.env.REDIS_PORT,auth_pass:process.env.REDIS_PASSWORD,db:0,ttl:6e3}):{get:()=>Promise.resolve(void 0),set:()=>Promise.resolve(void 0),del:()=>Promise.resolve(void 0)};const configRedisCache=(e,s=!0)=>{redisCache=s?e.caching({store:redisStore,db:0,ttl:6e3,...e}):e},getRedisCacheKey=(e,s)=>`${e}-${s}`,storeObjectInCache=(e,s,t)=>redisCache.set(getRedisCacheKey(e,s),JSON.stringify(t)),retrieveObjectInCache=(e,s)=>redisCache.get(getRedisCacheKey(e,s)).then(e=>void 0===e?e:JSON.parse(e)),deleteObjectInCache=(e,s)=>redisCache.del(getRedisCacheKey(e,s)),hash512=e=>crypto.createHash("sha512").update(e).digest("hex"),getAddress=(e,s=64)=>hash512(e).slice(0,s),PREFIX=getAddress(TRANSACTION_FAMILY,6),getTransactionAddress=e=>PREFIX+ADDRESS_PREFIX.TRANSACTION+getAddress(e,62),getUserAddress=e=>PREFIX+ADDRESS_PREFIX.USER+getAddress(e,62),findByAddress=(s,t,a=!1,r=null)=>{const o=e=>queryState(e).then(e=>{switch(storeObjectInCache(s,t,e),s){case TYPE.TRANSACTION:r&&r.locals&&(r.locals.transaction||(r.locals.transaction={}),r.locals.transaction[e.address]=new Transaction(e)),e=new Transaction(e).toObject(a);break;case TYPE.USER:r&&r.locals&&(r.locals.user||(r.locals.user={}),r.locals.user[e.address]=new User(e)),e=new User(e).toObject(a)}return e}).catch(e=>e.response&&e.response.data&&e.response.data.error&&75===e.response.data.error.code?null:Promise.reject(e));switch(s){case TYPE.TRANSACTION:return r&&r.locals&&r.locals.transaction&&r.locals.transaction[t]?Promise.resolve(new Transaction(r.locals.transaction[t]).toObject(a)):retrieveObjectInCache(s,t).then(e=>e?Promise.resolve(new Transaction(e).toObject(a)):o(getTransactionAddress(t)));case TYPE.USER:return r&&r.locals&&r.locals.user&&r.locals.user[t]?Promise.resolve(new User(r.locals.user[t]).toObject(a)):retrieveObjectInCache(s,t).then(e=>e?Promise.resolve(new User(e).toObject(a)):o(getUserAddress(t)))}},findAllObjects=(t,s,e=0,a=!1,r=null)=>{let o,c;switch(t){case TYPE.TRANSACTION:o="transaction",c=ADDRESS_PREFIX.TRANSACTION;break;case TYPE.USER:o="user",c=ADDRESS_PREFIX.USER}return axios.get(`${process.env.SAWTOOTH_REST}/state?address=${PREFIX+c}${0!==e?`&limit=${e}`:""}`,{headers:{"Content-Type":"application/json"}}).then(e=>{e=_.chain(e.data.data).filter(e=>!_.isEmpty(JSON.parse(Buffer.from(e.data,"base64")))).map(e=>{var s=JSON.parse(Buffer.from(e.data,"base64"));switch(storeObjectInCache(t,s.address,s),t){case TYPE.TRANSACTION:return r&&(r.locals.transaction||(r.locals.transaction={}),r.locals.transaction[s.address]=new Transaction(s)),new Transaction(s).toObject(a);case TYPE.USER:return r&&(r.locals.user||(r.locals.user={}),r.locals.user[s.address]=new User(s)),new User(s).toObject(a)}}).flatten().value();return logFormatted(`${s} | Querying all ${o}s - ${e.length} ${o}${1!==e.length?"s":""} found`,0===e.length?SEVERITY.ERROR:SEVERITY.SUCCESS),e})},buildBatch=({inputs:e,outputs:s,payload:t},...a)=>{let r=[new SawtoothTransaction({inputs:e,outputs:s,payload:t})];return(a||[]).forEach(e=>r.push(buildBatch(e))),[].concat.apply([],r)},_putObject=(e,a,r,s)=>{var t=s.address;let o=s.toString(!1,a),c,n;switch(deleteObjectInCache(e,t),e){case TYPE.TRANSACTION:n="Transaction",c=getTransactionAddress(t);break;case TYPE.USER:n="User",c=getUserAddress(t)}e=buildBatch({payload:o,inputs:[c],outputs:[c]});return logFormatted(`${r} | BATCH Request:`,SEVERITY.NOTIFY,...e),sendBatch(e).then(e=>{logFormatted(`${r}  | BATCH Response: ${e.status} - ${e.statusText}`,SEVERITY.SUCCESS);var s=a===HTTP_METHODS.POST?201:200,e=`${n} ${a===HTTP_METHODS.POST?"created":"updated"}`;const t=JSON.parse(o);return delete t.type,delete t.httpMethod,{responseCode:s,msg:e,payload:t}})},buildObjectTransaction=(e,s,t)=>{let a,r,o;switch(e){case TYPE.TRANSACTION:r=t.address,a=t.toString(!1,s),o=getTransactionAddress(r);break;case TYPE.USER:r=t.address,a=t.toString(!1,s),o=getUserAddress(r)}e=a;return new SawtoothTransaction({payload:e,inputs:[o],outputs:[o]})},putBatch=(a,r,o)=>{const c=buildBatch(...o);return o.forEach(e=>{e=JSON.parse(e.payload);deleteObjectInCache(e.type,e.address)}),logFormatted(`${r} | BATCH Request:`,SEVERITY.NOTIFY,c),sendBatch(c).then(e=>{logFormatted(`${r} | BATCH Response: ${e.status} - ${e.statusText}`,SEVERITY.SUCCESS);var s=a===HTTP_METHODS.POST?201:200,e=`Batch of ${o.length} transaction${1<o.length?"s":""} ${a===HTTP_METHODS.POST?"created":"updated"}`;const t=[];return c.forEach(e=>{const s=JSON.parse(e.payload);delete s.type,t.push(s)}),{responseCode:s,msg:e,payload:t}})},putObject=(e,s,t,a,r)=>{let o;return e===TYPE.USER&&(o=new User(a.body)),_putObject(e,s,t,o).then(({responseCode:e,msg:s,payload:t})=>r.status(e).json({msg:s,payload:t}))};module.exports.configRedisCache=configRedisCache,module.exports.hash512=hash512,module.exports.getTransactionAddress=getTransactionAddress,module.exports.getUserAddress=getUserAddress,module.exports.findByAddress=findByAddress,module.exports.findAllObjects=findAllObjects,module.exports._putObject=_putObject,module.exports.buildObjectTransaction=buildObjectTransaction,module.exports.putBatch=putBatch,module.exports.putObject=putObject;